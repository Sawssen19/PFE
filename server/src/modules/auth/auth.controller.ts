import { Request, Response } from 'express';
import { PrismaClient } from '@prisma/client';
import bcrypt from 'bcrypt';
import jwt from 'jsonwebtoken';
import { EmailService } from '../../services/emailService';
import crypto from 'crypto';
import { SmsService } from '../../services/smsService';
import dotenv from 'dotenv';

// üîß SECRET FIXE pour √©viter les erreurs JWT
const JWT_SECRET = 'kollecta-super-secret-jwt-key-2025';

// Charger les variables d'environnement avant d'initialiser Prisma
dotenv.config();
const prisma = new PrismaClient();

export class AuthController {
  async register(req: Request, res: Response) {
    try {
      const { email, password, firstName, lastName } = req.body;

      // V√©rifier si l'utilisateur existe d√©j√†
      const existingUser = await prisma.user.findUnique({
        where: { email }
      });

      if (existingUser) {
        return res.status(400).json({ message: 'Cet email est d√©j√† utilis√©' });
      }

      const hashedPassword = await bcrypt.hash(password, 10);

      // üîê G√©n√©rer un token de v√©rification unique (pour plus tard)
      const verificationToken = crypto.randomBytes(32).toString('hex');
      const verificationExp = new Date(Date.now() + 24 * 60 * 60 * 1000); // 24 heures

      // ‚úÖ SOLUTION COMPL√àTE : Forcer TOUS les champs de profil √† des valeurs par d√©faut
      const user = await prisma.user.create({
        data: {
          email,
          password: hashedPassword,
          firstName,
          lastName,
          // üîß FORCER tous les champs de profil √† des valeurs par d√©faut
          profilePicture: null,           // Pas de photo h√©rit√©e
          profileUrl: null,               // Pas d'URL h√©rit√©e
          profileDescription: null,       // Pas de description h√©rit√©e
          profileVisibility: 'private',   // Visibilit√© par d√©faut (string) - maintenant align√© avec Prisma
          // üîê Champs de v√©rification d'email
          verificationToken,
          verificationExp,
                      // ‚úÖ Email de v√©rification requis
            isVerified: false,
            // üîê Statut initial : PENDING (en attente de v√©rification email + KYC + approbation admin)
            status: 'PENDING',
            isActive: false,
          // Les autres champs utilisent les valeurs par d√©faut de Prisma
        },
      });

      // üìß Envoyer l'email de v√©rification avec SendGrid
      try {
        await EmailService.sendVerificationEmail(email, verificationToken, firstName);
        console.log('üìß Email de v√©rification envoy√© avec succ√®s via SendGrid √†:', email);
      } catch (emailError) {
        console.error('‚ö†Ô∏è Erreur lors de l\'envoi de l\'email de v√©rification:', emailError);
        // On continue m√™me si l'email √©choue
      }

      // üîî Envoyer un email de NOTIFICATION √† l'admin (vous)
      try {
        await EmailService.sendAdminNotification(email, firstName, lastName);
        console.log('üîî Email de notification admin envoy√© avec succ√®s √†: sawssen.yazidi@sesame.com.tn');
      } catch (adminEmailError) {
        console.error('‚ö†Ô∏è Erreur lors de l\'envoi de l\'email de notification admin:', adminEmailError);
        // On continue m√™me si l'email admin √©choue
      }

      // üîç D√âBOGAGE COMPLET : V√©rifier TOUS les champs apr√®s cr√©ation
      console.log('üîç NOUVEL UTILISATEUR CR√â√â - V√©rification compl√®te:');
      console.log('  - ID:', user.id);
      console.log('  - Email:', user.email);
      console.log('  - profilePicture:', user.profilePicture, '(type:', typeof user.profilePicture, ')');
      console.log('  - profileUrl:', user.profileUrl, '(type:', typeof user.profileUrl, ')');
      console.log('  - profileDescription:', user.profileDescription, '(type:', typeof user.profileDescription, ')');
      console.log('  - profileVisibility:', user.profileVisibility, '(type:', typeof user.profileVisibility, ')');
      console.log('  - isClean:', user.profilePicture === null && user.profileUrl === null && user.profileDescription === null);
      
      // V√©rifier si les valeurs correspondent √† ce qu'on attend
      if (user.profilePicture !== null || user.profileUrl !== null || user.profileDescription !== null) {
        console.log('üö® ALERTE: L\'utilisateur a des champs de profil non-null!');
        console.log('  - profilePicture attendu: null, re√ßu:', user.profilePicture);
        console.log('  - profileUrl attendu: null, re√ßu:', user.profileUrl);
        console.log('  - profileDescription attendu: null, re√ßu:', user.profileDescription);
      } else {
        console.log('‚úÖ SUCC√àS: Tous les champs de profil sont null comme attendu');
      }

      const token = jwt.sign(
        { userId: user.id },
        JWT_SECRET,
        { expiresIn: '24h' }
      );

      console.log('‚úÖ Nouvel utilisateur cr√©√© avec SUCC√àS:', {
        id: user.id,
        email: user.email,
        profilePicture: user.profilePicture,
        isClean: user.profilePicture === null
      });

      res.status(201).json({
        success: true,
        data: {
          user: {
            id: user.id,
            email: user.email,
            firstName: user.firstName,
            lastName: user.lastName,
            role: user.role,
            isVerified: user.isVerified, // ‚úÖ Maintenant true
            // ‚úÖ UTILISER LES VRAIES VALEURS DE LA BASE DE DONN√âES
            profilePicture: user.profilePicture,
            profileUrl: user.profileUrl,
            profileDescription: user.profileDescription,
            profileVisibility: user.profileVisibility,
          },
          token
        }
      });
    } catch (error) {
      console.error('Erreur lors de l\'inscription:', error);
      res.status(500).json({ message: 'Erreur lors de l\'inscription' });
    }
  }

  async login(req: Request, res: Response) {
    try {
      const { email, password } = req.body;

      const user = await prisma.user.findUnique({
        where: { email }
      });

      if (!user) {
        return res.status(401).json({ message: 'Email ou mot de passe incorrect' });
      }

      // üö® V√âRIFICATION : Bloquer UNIQUEMENT la connexion si une demande de SUPPRESSION est en cours
      console.log('üîç V√©rification des demandes de SUPPRESSION en cours pour:', email);
      
      try {
        const pendingDeletionRequest = await prisma.accountRequest.findFirst({
          where: {
            email: email,
            requestType: 'DELETION', // üéØ SEULEMENT les demandes de SUPPRESSION
            status: 'PENDING'
          }
        });
        
        console.log('üîç R√©sultat de la recherche de suppression:', pendingDeletionRequest);
        
        if (pendingDeletionRequest) {
          console.log('üö® Demande de SUPPRESSION en cours trouv√©e:', pendingDeletionRequest);
          
          // ‚ùå SUPPRESSION : Bloquer compl√®tement la connexion
          return res.status(403).json({ 
            success: false,
            message: `‚ùå Connexion bloqu√©e : Ce compte a une demande de suppression en cours de traitement. L'√©quipe Kollecta va examiner votre demande et vous contactera dans les plus brefs d√©lais.`,
            blocked: true,
            requestType: 'DELETION',
            submittedAt: pendingDeletionRequest.submittedAt
          });
        } else {
          console.log('‚úÖ Aucune demande de SUPPRESSION en cours trouv√©e');
        }
      } catch (error) {
        console.error('‚ùå Erreur lors de la v√©rification des demandes de suppression:', error);
      }

      const isPasswordValid = await bcrypt.compare(password, user.password);
      if (!isPasswordValid) {
        return res.status(401).json({ message: 'Email ou mot de passe incorrect' });
      }

      // üîê V√âRIFICATION : Bloquer la connexion si l'email n'est pas v√©rifi√©
      if (!user.isVerified) {
        return res.status(403).json({ 
          success: false,
          message: 'Veuillez v√©rifier votre email pour activer votre compte avant de vous connecter.',
          blocked: true,
          requiresVerification: true
        });
      }

      const token = jwt.sign(
        { userId: user.id },
        JWT_SECRET,
        { expiresIn: '24h' }
      );

      // üîç D√âBOGAGE LOGIN : V√©rifier les champs de profil
      console.log('üîç LOGIN - V√©rification des champs de profil:');
      console.log('  - profilePicture:', user.profilePicture);
      console.log('  - profileUrl:', user.profileUrl);
      console.log('  - profileDescription:', user.profileDescription);
      console.log('  - profileVisibility:', user.profileVisibility);

      // üéØ V√âRIFIER SI L'UTILISATEUR A UNE DEMANDE DE D√âSACTIVATION EN COURS
      let deactivationMessage = null;
      try {
        const deactivationRequest = await prisma.accountRequest.findFirst({
          where: {
            email: email,
            requestType: 'DEACTIVATION',
            status: 'PENDING'
          }
        });
        
        if (deactivationRequest) {
          deactivationMessage = `üéâ Nous sommes contents de votre retour ! Votre compte a une demande de d√©sactivation en cours de traitement. L'√©quipe Kollecta va examiner votre demande et vous contactera dans les plus brefs d√©lais.`;
        }
      } catch (error) {
        console.error('‚ùå Erreur lors de la v√©rification de d√©sactivation:', error);
      }

      res.json({
        success: true,
        data: {
          user: {
            id: user.id,
            email: user.email,
            firstName: user.firstName,
            lastName: user.lastName,
            role: user.role,
            isVerified: user.isVerified,
            // üîß AJOUTER TOUS les champs de profil
            profilePicture: user.profilePicture,
            profileUrl: user.profileUrl,
            profileDescription: user.profileDescription,
            profileVisibility: user.profileVisibility,
          },
          token,
          // üéØ MESSAGE SP√âCIAL POUR LES COMPTES D√âSACTIV√âS
          deactivationMessage
        }
      });
    } catch (error) {
      console.error('Erreur lors de la connexion:', error);
      res.status(500).json({ message: 'Erreur lors de la connexion' });
    }
  }

  async forgotPassword(req: Request, res: Response) {
    try {
      const { email, phone } = req.body;
      console.log('üîç Demande de r√©initialisation pour:', { email, phone });
      
      let user = null;
      let identifier = '';
      
      // Rechercher l'utilisateur par email ou num√©ro de t√©l√©phone
      if (email) {
        identifier = email;
        user = await prisma.user.findUnique({ where: { email } });
      } else if (phone) {
        // Nettoyer le num√©ro de t√©l√©phone (supprimer les espaces)
        const cleanPhone = phone.replace(/\s/g, '');
        identifier = cleanPhone;
        console.log('üì± Num√©ro de t√©l√©phone nettoy√©:', cleanPhone);
        
        // Rechercher avec le num√©ro nettoy√©
        user = await prisma.user.findFirst({ 
          where: { 
            phone: {
              contains: cleanPhone.replace('+', '') // Recherche partielle sans le +
            }
          } 
        });
        
        if (!user) {
          // Essayer avec le num√©ro exact
          user = await prisma.user.findFirst({ where: { phone: cleanPhone } });
        }
        
        if (!user) {
          // Essayer avec le num√©ro original (avec espaces)
          user = await prisma.user.findFirst({ where: { phone: phone } });
        }
      } else {
        return res.status(400).json({ 
          message: 'Veuillez fournir un email ou un num√©ro de t√©l√©phone.' 
        });
      }
      
      if (!user) {
        console.log('‚ùå Utilisateur non trouv√© pour:', identifier);
        // Pour des raisons de s√©curit√©, on ne r√©v√®le pas si l'identifiant existe ou non
        return res.status(200).json({ 
          message: 'Si cet identifiant existe dans notre base de donn√©es, vous recevrez un lien de r√©initialisation.' 
        });
      }

      console.log('‚úÖ Utilisateur trouv√©:', user.id, user.firstName);
      
      // G√©n√©rer un token de r√©initialisation unique avec crypto (plus s√©curis√© que JWT)
      const resetToken = crypto.randomBytes(32).toString('hex');
      const resetTokenExp = new Date(Date.now() + 1 * 60 * 60 * 1000); // 1 heure
      
      console.log('üîë Token g√©n√©r√©:', resetToken.substring(0, 10) + '...');

      await prisma.user.update({
        where: { id: user.id },
        data: {
          resetToken,
          resetTokenExp
        }
      });
      
      console.log('üíæ Token sauvegard√© en base de donn√©es');

      // Envoyer la r√©initialisation par email ou SMS
      try {
        if (email) {
          console.log('üìß Tentative d\'envoi d\'email √†:', email);
          await EmailService.sendPasswordResetEmail(email, user.firstName, resetToken);
          console.log('üìß Email de r√©initialisation envoy√© avec succ√®s √†:', email);
          
          // R√©ponse pour email
          return res.status(200).json({ 
            message: 'Si cet identifiant existe dans notre base de donn√©es, vous recevrez un lien de r√©initialisation par email.',
            method: 'email'
          });
          
        } else if (phone) {
          console.log('üì± Tentative d\'envoi de SMS √†:', phone);
          const smsResult = await SmsService.sendPasswordResetSMS(phone, user.firstName, resetToken);
          
          if (smsResult.success) {
            console.log('üì± SMS de r√©initialisation envoy√© avec succ√®s √†:', phone);
            // Retourner le lien de r√©initialisation dans la r√©ponse
            return res.status(200).json({
              message: 'SMS de r√©initialisation envoy√© avec succ√®s',
              method: 'SMS',
              resetUrl: smsResult.resetUrl,
              token: resetToken,
              expiresAt: new Date(Date.now() + 60 * 60 * 1000).toISOString() // 1 heure
            });
          } else {
            throw new Error('Erreur lors de l\'envoi du SMS de r√©initialisation');
          }
        }
      } catch (sendError) {
        console.error('‚ùå Erreur lors de l\'envoi de la r√©initialisation:', sendError);
        return res.status(500).json({ message: 'Erreur lors de l\'envoi des instructions de r√©initialisation' });
      }
    } catch (error) {
      console.error('Erreur lors de la r√©initialisation du mot de passe:', error);
      res.status(500).json({ message: 'Erreur lors de la r√©initialisation du mot de passe' });
    }
  }

  async resetPassword(req: Request, res: Response) {
    try {
      const { token, newPassword } = req.body;
      
      // V√©rifier si le token existe et n'est pas expir√© (sans JWT)
      const user = await prisma.user.findFirst({
        where: { 
          resetToken: token,
          resetTokenExp: { gt: new Date() }
        }
      });

      if (!user) {
        return res.status(400).json({ 
          message: 'Token invalide ou expir√©. Veuillez demander un nouveau lien de r√©initialisation.' 
        });
      }

      const hashedPassword = await bcrypt.hash(newPassword, 10);

      await prisma.user.update({
        where: { id: user.id },
        data: {
          password: hashedPassword,
          resetToken: null,
          resetTokenExp: null
        }
      });

      console.log('‚úÖ Mot de passe r√©initialis√© avec succ√®s pour:', user.email);

      res.json({ 
        message: 'Votre mot de passe a √©t√© r√©initialis√© avec succ√®s. Vous pouvez maintenant vous connecter.' 
      });
    } catch (error) {
      console.error('Erreur lors de la r√©initialisation du mot de passe:', error);
      res.status(500).json({ message: 'Erreur lors de la r√©initialisation du mot de passe' });
    }
  }

  // üîê V√©rifier l'email avec le token
  async verifyEmail(req: Request, res: Response) {
    try {
      const { token } = req.body;

      if (!token) {
        return res.status(400).json({ message: 'Token de v√©rification requis' });
      }

      // üîç Chercher l'utilisateur avec ce token
      const user = await prisma.user.findFirst({
        where: {
          verificationToken: token,
          verificationExp: {
            gt: new Date() // Token non expir√©
          }
        }
      });

      if (!user) {
        return res.status(400).json({ 
          message: 'Token de v√©rification invalide ou expir√©' 
        });
      }

      // ‚úÖ Marquer l'email comme v√©rifi√©
      await prisma.user.update({
        where: { id: user.id },
        data: {
          isVerified: true,
          verificationToken: null, // Supprimer le token utilis√©
          verificationExp: null
        }
      });

      console.log('‚úÖ Email v√©rifi√© avec succ√®s pour:', user.email);

      res.json({
        success: true,
        message: 'Email v√©rifi√© avec succ√®s !'
      });
    } catch (error) {
      console.error('Erreur lors de la v√©rification de l\'email:', error);
      res.status(500).json({ message: 'Erreur lors de la v√©rification' });
    }
  }

  // üîÑ Renvoyer un nouveau code de v√©rification
  async resendVerification(req: Request, res: Response) {
    try {
      const { email } = req.body;

      if (!email) {
        return res.status(400).json({ message: 'Email requis' });
      }

      // üîç Chercher l'utilisateur
      const user = await prisma.user.findUnique({
        where: { email }
      });

      if (!user) {
        return res.status(404).json({ message: 'Utilisateur non trouv√©' });
      }

      if (user.isVerified) {
        return res.status(400).json({ message: 'Cet email est d√©j√† v√©rifi√©' });
      }

      // üîê G√©n√©rer un nouveau token de v√©rification
      const verificationToken = crypto.randomBytes(32).toString('hex');
      const verificationExp = new Date(Date.now() + 24 * 60 * 60 * 1000); // 24 heures

      // üíæ Mettre √† jour le token dans la base
      await prisma.user.update({
        where: { id: user.id },
        data: {
          verificationToken,
          verificationExp
        }
      });

      // üìß Envoyer le nouvel email de v√©rification
              await EmailService.sendResendVerificationEmail(email, verificationToken, user.firstName);

      console.log('üîÑ Nouveau code de v√©rification envoy√© √†:', email);

      res.json({
        success: true,
        message: 'Un nouveau code de v√©rification a √©t√© envoy√© √† votre email'
      });
    } catch (error) {
      console.error('Erreur lors du renvoi du code de v√©rification:', error);
      res.status(500).json({ message: 'Erreur lors de l\'envoi du code' });
    }
  }

  // üîë V√âRIFICATION DE LA VALIDIT√â D'UN TOKEN DE R√âINITIALISATION
  async verifyResetToken(req: Request, res: Response) {
    try {
      const { token } = req.params;

      // V√©rifier si le token existe et n'est pas expir√©
      const user = await prisma.user.findFirst({
        where: {
          resetToken: token,
          resetTokenExp: {
            gt: new Date() // Token non expir√©
          }
        }
      });

      if (!user) {
        return res.status(400).json({ 
          valid: false,
          message: 'Token invalide ou expir√©' 
        });
      }

      res.status(200).json({ 
        valid: true,
        message: 'Token valide' 
      });

    } catch (error) {
      console.error('‚ùå Erreur lors de la v√©rification du token:', error);
      res.status(500).json({ 
        valid: false,
        message: 'Erreur lors de la v√©rification du token' 
      });
    }

    try {
      const { token } = req.params;

      // V√©rifier si le token existe et n'est pas expir√©
      const user = await prisma.user.findFirst({
        where: {
          resetToken: token,
          resetTokenExp: {
            gt: new Date() // Token non expir√©
          }
        }
      });

      if (!user) {
        return res.status(400).json({ 
          valid: false,
          message: 'Token invalide ou expir√©' 
        });
      }

      res.status(200).json({ 
        valid: true,
        message: 'Token valide' 
      });

    } catch (error) {
      console.error('‚ùå Erreur lors de la v√©rification du token:', error);
      res.status(500).json({ 
        valid: false,
        message: 'Erreur lors de la v√©rification du token' 
      });
    }
  }
}